# NAVER CAMPUS HACKDAY - 댓글 증감수 기반 콘텐츠 랭킹 시스템 개발

### 주제 선정 배경

수많은 컨텐츠가 이미 생성 되어있고 새로 생성이 되는데, 컨텐츠에 작성된 댓글 최신 목록을 조회하고 특정 기간 동안 댓글의 증감을 표시하고 랭킹순으로 조회할 수 있는 페이지 개발.



### 개발환경
* Ubuntu 16.04 LTS
* MySQL 5.7.17
* JDK 1.8
* Spring, mybatis



### 문제 스펙

*   몇 개의 오브젝트에 대해서 몇 건 이상의 댓글을 초당 발생시켜야 한다.
    (순차적으로 하나씩 증가하는 로직이 아닌 랜덤하게 저장되고 동일한 서비스+컨텐츠에 저장도 되어야 한다)
*   컨텐츠는 이미 천만개 존재한다.
*   새로운 컨텐츠는 실시간으로 추가된다.
*   1분 주기로 댓글 증감 기준, 베스트 컨텐츠를 뽑는다.
*   배치는 매분 마다 실행된다.
*   분 단위로 베스트 컨텐츠를 뽑을 수 있어야 한다.(web 구현)

컨텐츠 전체 수는 계속 증가한다고 전제

분당 30000개 댓글을 추가/삭제/업데이트 하는 코드 구현 (멘토님께서 구현)

이전 기간과의 댓글 증감 수 표시, 여기서 이전 기간은 일반적으로 1분을 말하지만 그 외 다양한 기간에 대해서도 증감 수를 구할 수 있게 확장성을 생각하면서 개발

N분마다 컨텐츠 랭킹 갱신

댓글 추가/삭제/업데이트를 멘토님께서 db에 추가해주시면 멘티들은 그 추가된 댓글들을 가지고 읽고 분석하는 코드를 작성했다. 또는 상황에 따라서 멘토님이 댓글을 추가하는 코드를 멘티가 수정하는 것도 가능했다. 



### 문제 해결과정

1.  컨텐츠와 댓글들은 이미 천만개 이상 존재하지만 그것들을 다 읽을 필요가 없다.(다 읽어서도 안된다...)

    우리가 관심있는 것은 최근 날짜에 어느 컨텐츠에서 댓글들이 얼마나 추가/삭제/변경되었는지만 관심있다. 따라서 매 N분마다 추가된 댓글들만 읽으면 된다.

    1.  처음엔 분 당 약 30000개씩 추가되는 댓글을 '어떻게하면 읽고 분석해서 증감이 가장 큰 순으로 sorting 할 수 있을까?'에 대해서 고민했다. 그래서 여전히 분당 30000개의 개수는 많다고 생각했기 때문에 멀티스레드로 분 당 추가되는 N개의 댓글들을 처리하는 방법을 생각했다.

        각 스레드에서 자신에게 할당된 댓글에서 service_id, content_id, reg_ymdt를 가지고 새로운 키를 만든 뒤 증감 수만 캐시서버에 저장하는 방법을 생각했다. 그래서 매 N분마다 배치를 돌릴 때 우리가 캐시서버에 키에 reg_ymdt를 넣어서 만들었기 때문에 그것을 이용해서 우리가 필요한 기간의 증감 수를 뽑아내면된다.

    2.  JUnit에서 동시성 테스트를 위한 플러그인(junit-concurrent)을 이용해서 다음과 같은 방식으로 테스트코드를 작성했다.

        ```java
        @Runwith(ConcurrentRunner.class)
        public void test() {
          @Test
          public void thread_1() { ... }
          @Test
          public void thread_2() { ... }
          ...
        }
        ```

        ![](http://drive.google.com/uc?export=view&id=1VV4fdsqsAQ643-fVjaZ0o_IqwrBJVAYp)

        ​

2.  생각해보니 굳이 N분때 분석을 해야하는가에 대해서 조금 의문이 들었다. 실 서비스에서는 꼭 분당 30000개의 댓글이 달리라는 법도 없기 때문이다. 차라리 댓글이 추가될 때마다 분석(댓글의 service_id, content_id, reg_ymdt로 pk를 만들고 해당 pk에 증감수를 업데이트 시켜주는 일)을 끝내고 캐시서버에 추가하면 배치를 돌릴 땐 내가 원하는 기간에서 테이블을 읽기만 하면 끝난다. 

    *   배치가 해야하는 일이 훨씬 줄어드는 셈이다. 다이어그램을 보면 알겠지만 원본 댓글 테이블을 직접 읽어들일 일이 없어진다.
    *   테스트하기 힘들었던 멀티스레드도 사용할 필요가 없어진다 :)

    ![](http://drive.google.com/uc?export=view&id=1GfZk3Lgig63qefHW5ml3wKg7WFiHksxc)

    ​

    ​

### 느낀 점, 배운 것들

1.  데이터 양이 많다 보니, 그리고 실시간 데이터이다보니 SELECT 쿼리가 상당히 부담되었다. timeout에 걸릴 수도 있고 Non repeatable read, Phantom read 문제도 발생할 수 있을 것 같았다.

    최대한 원본테이블(원본 댓글 테이블)을 직접 읽는 것을 피하고 내가 원하는 데이터만을 저장하는 테이블(증감 수 랭킹 테이블)을 따로 만들어 그것을 읽을 수 있는 방법을 선택해야 할 것 같다.

    ​

    다른 비슷한 문제 상황에서도 Data source로 쓸 수 있는 테이블을 하나 만들어 놓고 거기서 내가 이용하고 싶은 데이터를 따로 저장할 수 있는, 그리고 부담없이 쿼리할 수 있는 테이블을 여럿두어 해결하고자 하는 문제를 풀면 좋을 것 같다.

    ​

2.  이번 문제를 해결하면서 또 하나 어려웠던 점은 어떻게하면 내가 원하는 기간에 대해서 조회를 할 수 있을까라는 것이었다. 멘토님 덕분에 배울 수 있었던 팁 중에 하나는 pk에 reg_ymdt를 넣는 방법이다.

    이번에는 service_id|content_id|yyyyMMddHHmm 와 같은 형태의 키를 랭킹테이블에 저장했는데 처음에는 왜 reg_ymdt를 넣을까 잘 이해가 안됐는데 생각해보니,

    예를 들어 시간별 랭킹 조회가 필요하다면 HH만 읽어서 비교하면 되고 월별 조회는 MM만 읽어서 비교하면 된다. 따로 테이블을 만들거나 컬럼을 추가할 필요없이 date만 키에 추가하면 한 번에 해결되었다. 이번에는 분당 랭킹을 갱신해야했기 때문에 mm을 배치를 돌릴 때마다 비교해서 SELECT하였다.

     

    ​
